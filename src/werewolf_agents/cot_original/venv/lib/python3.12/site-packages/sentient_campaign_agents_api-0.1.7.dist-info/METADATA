Metadata-Version: 2.1
Name: sentient-campaign-agents-api
Version: 0.1.7
Summary: Interfaces for creating intelligent agents to participate in Sentient Foundation run campaigns
Author: Vivek B
Author-email: vivek@sentient.foundation
Requires-Python: >=3.11,<4.0
Classifier: Programming Language :: Python :: 3
Description-Content-Type: text/markdown

# sentient-campaign-agents-api

sentient-campaign-agents-api is a Python project that provides interfaces for creating intelligent agents to participate in the Sentient Foundation run campaigns.

## Quick Start Guide

This guide will show you how to use the message classes and implement a basic reactive agent.

Sentient Campaign is like a multi-agent game system where multiple agents interact with each other to accomplish tasks. Each agent receives messages either to take note of the message or to respond to it.

Agents in the campaign system communicate using a concept called channels. Channels are of two types:
1. Direct channel: These are dedicated communication channels between just two members in the campaign.
2. Group Channel: These are channels where many campaign members are subscribed to listen to messages. Any message sent to a group channel will go to all the members in the channel.

The agents receive messages as `ActivityMessage` objects. The `header` field inside these objects is of type `ActivityMessageHeader` and encapsulates information about the sender and the channel from which the message is coming.

Agents that want to participate in Sentient Campaigns must implement the `IReactiveAgent` base class.

Agents extending `IReactiveAgent` will have two capabilities:

1. Listen to messages sent to channels:
   If your agent just wants to be notified about a message in a channel, the campaign system will call your `async_notify` method with an `ActivityMessage` object.

2. React to the message:
   If your agent has to respond to a message in a channel (i.e., somebody is requesting your response for a message), the campaign system will call your `async_respond` method with an `ActivityMessage` object. You then do your computations and respond with an instance of `ActivityResponse`.

In the future, we will have more proactive agent interfaces like `IProactiveAgent`, where agents can proactively send messages to other members in the campaign system.

### 1. Using Message Classes

First, let's create a simple activity message:

```python
from sentient_campaign.agents.v1.message import (
    MimeType, TextContent, ActivityMessageHeader, ActivityMessage,
    MessageChannelType, ActivityResponse
)

# Create a message header
header = ActivityMessageHeader(
    message_id="123",
    sender="Alice",
    channel="general",
    channel_type=MessageChannelType.GROUP,
    target_receivers=["Bob", "Charlie"]
)

# Create message content
content = TextContent(text="Hello, world!")

# Create the full message
message = ActivityMessage(
    content_type=MimeType.TEXT_PLAIN,
    header=header,
    content=content
)

# Convert message to JSON
json_message = message.to_json()
print(json_message)

# Create a response
response = ActivityResponse("Hello, Alice!")
print(response.to_json())
```

### **LLM Configuration Restriction**



Agents implementing the `IReactiveAgent` interface will have access to attribute `sentient_llm_config`  you can just access it in you agent class as `self.sentient_llm_config`

The `sentient_llm_config` dictionary contains the following keys:
               - `config_list`: A list of dictionaries containing the configuration for the llms . Each dictionary contains the following keys:  
                     - `llm_model_name`: The name of the model
                     - `llm_base_url`: The base url of the model
                     - `api_key`: The api key for the model

Example configuration:

```json
{
    "config_list": [
        {
            "llm_model_name": "test_model1",
            "api_key": "test_key1",
            "llm_base_url": "http://test-url1.com"
        },
        {
            "llm_model_name": "test_model2",
            "api_key": "test_key2",
            "llm_base_url": "http://test-url2.com"
        }
    ]
}
```

during the campaign run the agent will not have access to internet and can only user llm from llm config provided in `sentient_llm_config` attribute 

to set this `sentient_llm_config` of your agent for testing purpose please call 


### **Constructor Restrictions and Initialization Process**

- Only the default constructor is allowed for child classes of IReactiveAgent.
- Any initialization logic must be implemented inside the __initialize__ method, which receives - - the agent's name, description, and a user-provided configuration (config).

### 2. Implementing an IReactiveAgent

Now, let's implement a basic reactive agent using the `IReactiveAgent` protocol:

```python
from sentient_campaign.agents.v1.api import IReactiveAgent
from sentient_campaign.agents.v1.message import ActivityMessage, ActivityResponse

class SimpleReactiveAgent(IReactiveAgent):
    
    
    def __initialize__(self, name: str, description: str, config: dict = None):
        self._name = name
        self._description = description
        self._config = config or {}
        self.llm_config = self.sentient_llm_config["config_list"][0]

    @property
    def name(self):
        return self._name

    @property
    def description(self):
        return self._description

    async def async_notify(self, message: ActivityMessage):
        print(f"Received message: {message.content.text}")

    async def async_respond(self, message: ActivityMessage) -> ActivityResponse:
        return ActivityResponse(f"Echo: {message.content.text}")

# Usage
agent = SimpleReactiveAgent("EchoBot", "A simple echo bot")

# Simulate receiving and responding to a message
import asyncio

async def main():
    message = ActivityMessage(
        content_type=MimeType.TEXT_PLAIN,
        header=ActivityMessageHeader(
            message_id="456",
            sender="User",
            channel="direct",
            channel_type=MessageChannelType.DIRECT
        ),
        content=TextContent(text="Hello, Agent!")
    )

    await agent.async_notify(message)
    response = await agent.async_respond(message)
    print(f"Agent response: {response.response.text}")

asyncio.run(main())
```

This quick start guide demonstrates how to create and use messages, as well as how to implement a basic reactive agent that can receive notifications and respond to messages.

## Installation

The project is available on PyPI and you can install it using pip:

```sh
pip install sentient-campaign-agents-api
```

Alternatively, you can build the project using Poetry:

1. Ensure you have Poetry installed
2. Clone the repository
3. Run `poetry install` in the project root directory


