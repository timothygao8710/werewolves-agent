import base64
import email
import json
from pathlib import PurePosixPath
import re
import shutil
from typing import List, Union
from urllib.parse import urlparse
import zipfile
import os
from jinja2 import Template
import docker
import tempfile
import logging
from docker.errors import APIError, ContainerError
import time
from datetime import datetime
import tarfile
import io
from docker.models.containers import Container
from docker.models.images import Image
from typing import Protocol

from sentient_campaign.activity_runner.utils import add_console_log_handler



logger = logging.getLogger(__name__)
log_level = logging.INFO
if os.environ.get("SENTIENT_ENABLE_RUNNER_DEBUG_LOGS", "false") == "true":
    log_level = logging.DEBUG
logger = add_console_log_handler(logger, level=log_level)


class AgentContainerError(Exception):
    def __init__(self, message):
        super().__init__(message)


class AgentImageProvider(Protocol):

    def get_image(self) -> Image:
        pass

    def get_image_tags(self) -> List[str]:
        pass


class ECRBasedAgentImageProvider(AgentImageProvider):

    def __init__(
        self,
        docker_client: docker.DockerClient,
        ecr_image_uri: str,
        login_config,
        force_repull: bool = False,
    ):
        super().__init__()
        self.image_uri = ecr_image_uri
        self.image = None
        self.login_config = login_config
        self.force_repull = force_repull
        self.docker_client = docker_client
        

    def get_image(self):
        if self.image:
            return self.image
        try:
            if not self.force_repull:
                logger.info(f"checking if image exists locally: {self.image_uri}")
                self.image = self.docker_client.images.get(self.image_uri)
                return self.image
        except docker.errors.ImageNotFound:
            logger.info(f"Pulling image: {self.image_uri}")
        try:
            if self.force_repull:
                self.docker_client.images.remove(self.image_uri)
                logger.info(f"Removed local image: {self.image_uri}")
        except docker.errors.ImageNotFound:
            logger.info(f"Image not found locally: {self.image_uri}")
        except docker.errors.APIError as e:
            logger.error(f"Error removing image: {str(e)}")

        try:
            logger.info("Image not present locally, proceeding to pull.")
            self.image = self.docker_client.images.pull(self.image_uri)
            logger.info(f"Successfully pulled image: {self.image_uri}")
            return self.image
        except docker.errors.APIError as e:
            logger.error(f"Docker API error: {str(e)}")
            raise e
        except Exception as e:
            logger.error(f"An unexpected error occurred: {str(e)}")
            raise e

    def get_image_tags(self):
        if self.image:
            return self.image.tags
        self.image = self.get_image()
        return self.image.tags


class WheelBasedAgentImageProvider(AgentImageProvider):

    def __init__(
        self, docker_client, image_name, path_to_wheel_file, force_rebuild=True
    ):
        self.path_to_wheel_file = path_to_wheel_file
        self.image_name = image_name
        self.image = None
        self.docker_client = docker_client
        self.force_rebuild = force_rebuild
        self.agent_base_image_name = "public.ecr.aws/u2d4o0f0/sentient_foundation/sentient_campaign_werewolf_agent_base:0.3.7"
        if os.getenv("SENTIENT_AGENT_BASE_IMAGE"):
            self.agent_base_image_name = os.getenv("SENTIENT_AGENT_BASE_IMAGE")

    @staticmethod
    def _extract_metadata_from_wheel(wheel_path):
        try:
            with zipfile.ZipFile(wheel_path) as wheel:
                dist_info_metadata_path = next(
                    (f for f in wheel.namelist() if f.endswith(".dist-info/METADATA")),
                    None,
                )
                if not dist_info_metadata_path:
                    raise ValueError(
                        "Could not find METADATA file in .dist-info directory in wheel"
                    )

                with wheel.open(dist_info_metadata_path) as metadata_file:
                    metadata = email.message_from_binary_file(metadata_file)

                requires_python = metadata.get("Requires-Python", "")
                python_version = None

                match = re.search(r">=(\d+\.\d+)", requires_python)
                if match:
                    python_version = match.group(1)
                else:
                    logger.warning(
                        f"Could not parse Python version from '{
                                   requires_python}'. Using default."
                    )

                return {
                    "python_version": python_version or "3.12",
                    "name": metadata.get("Name", "unknown"),
                    "version": metadata.get("Version", "0.0.0"),
                }
        except zipfile.BadZipFile:
            logger.error(
                f"The file at {
                         wheel_path} is not a valid wheel file."
            )
            raise
        except Exception as e:
            logger.error(f"An error occurred while extracting metadata: {str(e)}")
            raise

    def get_image_tags(self):
        if self.image:
            return self.image.tags
        self.image = self.get_image()
        return self.image.tags

    def get_image(self) -> Image:
        """
        Create a docker image from a wheel file
        """
        if self.image:
            return self.image

        try:
            metadata = self._extract_metadata_from_wheel(self.path_to_wheel_file)
            python_version = metadata["python_version"]

            try:
                existing_image = self.docker_client.images.get(self.image_name)
                if existing_image and self.force_rebuild == False:
                    self.image = existing_image
                    return existing_image
                logger.info(f"Removing existing image: {self.image_name}")
                self.docker_client.images.remove(self.image_name)
            except docker.errors.ImageNotFound:
                logger.info(f"No existing image found for {self.image_name}")

            current_file_folder = os.path.dirname(os.path.abspath(__file__))
            resource_folder = os.path.join(current_file_folder, "resources")
            dockerfile_template_path = os.path.join(
                resource_folder, "agent_dockerfile.template"
            )
            agents_requirements_path = os.path.join(
                resource_folder, "agent_requirements.txt"
            )

            if not os.path.exists(dockerfile_template_path):
                raise FileNotFoundError(
                    f"Dockerfile template not found at {
                                        dockerfile_template_path}"
                )
            if not os.path.exists(agents_requirements_path):
                raise FileNotFoundError(
                    f"Requirements file not found at {
                                        agents_requirements_path}"
                )

            with open(dockerfile_template_path, "r") as f:
                dockerfile_content = Template(f.read()).render(
                    sentient_agent_base_image=self.agent_base_image_name,
                    agent_python_version=python_version,
                    sentient_agent_wheel_file=os.path.basename(self.path_to_wheel_file),
                    sent_agent_requirements_file="requirements.txt",
                )

            with tempfile.TemporaryDirectory() as tmpdir:
                with open(os.path.join(tmpdir, "Dockerfile"), "w") as f:
                    f.write(dockerfile_content)

                with open(agents_requirements_path, "r") as af, open(
                    os.path.join(tmpdir, "requirements.txt"), "w"
                ) as f:
                    f.write(af.read())

                for file_path in [self.path_to_wheel_file, agents_requirements_path]:
                    if not os.path.exists(file_path):
                        raise FileNotFoundError(f"Required file not found: {file_path}")
                    shutil.copy(file_path, tmpdir)

                logger.info(f"Building Docker image: {self.image_name}")
                for line in self.docker_client.api.build(
                    path=tmpdir,
                    tag=self.image_name,
                    decode=True,
                    rm=True,
                ):
                    if "stream" in line:
                        log_line = line["stream"].strip()
                        if log_line:
                            logger.info(log_line)
                    elif "error" in line:
                        logger.error(line["error"])
                        raise Exception(f"Error building Docker image: {line['error']}")

            self.image = self.docker_client.images.get(self.image_name)
            logger.info(f"Successfully built the image: {self.image_name}")
            return self.image

        except docker.errors.BuildError as e:
            logger.error(f"Docker build error: {str(e)}")
            raise
        except docker.errors.APIError as e:
            logger.error(f"Docker API error: {str(e)}")
            raise
        except Exception as e:
            logger.error(f"An unexpected error occurred: {str(e)}")
            raise


class AgentContainerRunner:

    def __init__(
        self,
        docker_client,
        container_network_name: str,
        image_provider: AgentImageProvider,
    ) -> None:
        self.image_provider = image_provider
        self.image = None
        self.containers: Container = {}
        self.client = docker_client
        self.executions = {}
        self.network_name = container_network_name

    def start_container(
        self,
        container_name: str,
        environment: dict = {},
        cpu_count: str = 1,
        mem_limit: str = "1g",
        process_limit: int = 10000,
    ):
        try:
            logger.info(f"Running container  {container_name}")
            if not self.image:
                logger.info(" looking for image ")
                self.image = self.image_provider.get_image()


            container = self.client.containers.run(
                self.image,
                detach=True,
                name=container_name,
                environment=environment,
                cpu_count=cpu_count,  # Allocate 4 CPUs
                mem_limit=mem_limit,  # 2GB memory limit
                pids_limit=process_limit,  # Allow up to 30 processes
                ulimits=[
                    docker.types.Ulimit(
                        name="nproc", soft=process_limit, hard=process_limit
                    )
                ],
                tty=True,  # Allocate a pseudo-TTY
                stdin_open=True,  # Keep STDIN open
                init=True,  # U
                network=self.network_name,
            )
            self.containers[container_name] = container

            # Check if the container started successfully
            time.sleep(5)
            if not self._check_container_status(container):
                raise ContainerError(container, 125, "Container failed to start")

            logger.info(f"Container  {container_name} started successfully")

            return container
        except (APIError, ContainerError) as e:
            logger.error(
                f"Error running container for {
                         container_name}: {str(e)}"
            )
            raise e

    def copy_to_container(self, container_name, src, dest, dest_file_name):
        container = self.containers.get(container_name)
        if not container:
            logger.error(f"No container found for name: {container_name}")
            return False

        try:
            # Create a tarfile of the source
            tar_stream = io.BytesIO()
            with tarfile.open(fileobj=tar_stream, mode="w") as tar:
                if os.path.isdir(src):
                    for root, dirs, files in os.walk(src):
                        for file in files:
                            file_path = os.path.join(root, file)
                            arcname = os.path.relpath(file_path, src)
                            tar.add(file_path, arcname=arcname)
                else:
                    tar.add(src, arcname=dest_file_name)
            tar_stream.seek(0)

            # Copy the tar stream to the container
            container.put_archive(dest, tar_stream)
            logger.info(
                f"Successfully copied {src} to {
                        dest} in container {container_name}"
            )
            return True
        except APIError as e:
            logger.error(
                f"Error copying files to container {
                         container_name}: {str(e)}"
            )
            return False

    @staticmethod
    def _copy_file_from_container(
        container: Container, container_file_path, host_file_path
    ):
        container.reload()
        stream, _ = container.get_archive(container_file_path)
        try:
            # Ensure the local directory exists
            os.makedirs(os.path.dirname(host_file_path), exist_ok=True)

            # Open the local file for writing
            with open(host_file_path, "wb") as local_file:
                # Stream and write the file content
                for chunk in stream:
                    local_file.write(chunk)

            print(
                f"File successfully streamed from container and saved to {
                  host_file_path}"
            )
            return True

        except docker.errors.NotFound:
            print(f"Container {container.id} not found")
        except docker.errors.APIError as e:
            print(f"Error accessing the Docker API: {e}")
        except IOError as e:
            print(f"I/O error({e.errno}): {e.strerror}")
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
        return False

    def copy_file_from_container(
        self, container_name, container_file_path, host_file_path
    ):

        container = self.containers.get(container_name)
        return AgentContainerRunner._copy_file_from_container(
            container, container_file_path, host_file_path
        )

    def copy_agent_log_file_from_container(self, player_name, host_file_path):
        execution_info = self.executions.get(player_name, None)
        if not execution_info:
            logger.error(f"No execution found for player: {player_name}")
            return AgentContainerError(f"No execution found for player: {player_name}")
        container: Container = self.containers.get(execution_info["container_name"])
        log_file_path = execution_info["log_file_path"]
        return AgentContainerRunner._copy_file_from_container(
            container, log_file_path, host_file_path
        )

    def _wrap_redirection_to_container_exec_command(
        self, command: Union[str, list], posix_log_path: PurePosixPath, append=False
    ):
        redirect_operator = ">>" if append else ">"
        log_file_path = str(posix_log_path)
        log_dir = str(posix_log_path.parent)

        if isinstance(command, list):
            command = " ".join(command)
        wrapped_command = [
            "/bin/sh",
            "-c",
            f"mkdir -p {log_dir} && "
            f"touch {log_file_path} && "
            f"{command} {redirect_operator} {log_file_path} 2>&1",
        ]
        return wrapped_command

    def run_sentient_default_agent_in_container(
        self,
        sentient_llm_config,
        agent_container_name,
        campaign_name,
        player_name,
        activity_id,
        transcript_manager_config_file_path,
        controller_container_name,
        max_retries=1,
    ):
        container = self.containers.get(agent_container_name)
        if not container:
            logger.error(
                f"No container found for name: {
                         agent_container_name}"
            )
            return None

        container_transcript_manager_config_file_path = (
            self._copy_and_get_container_transcript_manager_config_path(
                agent_container_name,
                player_name,
                activity_id,
                transcript_manager_config_file_path,
            )
        )

        container_log_file_path = self._get_container_output_redirect_log_posix_path(
            player_name, activity_id
        )

        sentient_llm_config_json_b64 = self.serialize_llm_config_to_b64(
            sentient_llm_config
        )

        command = [
            f"python /sent_lib/agent_loader/default_agent_loader.py "
            f"--controller_container_name {controller_container_name} "
            f"--campaign_name {campaign_name} "
            f"--player_name {player_name} "
            f"--activity_id {activity_id} "
            f"--player_name {player_name} "
            f"--sentient_llm_config_json_b64 {sentient_llm_config_json_b64} "
            f"--transcript_manager_config_path {
                container_transcript_manager_config_file_path} "
        ]
        redirected_command = self._wrap_redirection_to_container_exec_command(
            command, container_log_file_path
        )
        self._run_start_agent_command_in_container(
            agent_container_name,
            player_name,
            str(container_log_file_path),
            redirected_command,
            max_retries=max_retries,
        )

    def serialize_llm_config_to_b64(self, sentient_llm_config):
        sentient_llm_config_json = json.dumps(sentient_llm_config)
        sentient_llm_config_json_b64 = base64.b64encode(
            sentient_llm_config_json.encode("utf-8")
        ).decode("utf-8")
        return sentient_llm_config_json_b64

    def run_user_agent_in_container(
        self,
        sentient_llm_config,
        agent_container_name,
        agent_module_path,
        agent_class_name,
        campaign_name,
        player_name,
        activity_id,
        agent_config_path,
        transcript_manager_config_file_path,
        controller_container_name,
        max_retries=1,
    ):
        container = self.containers.get(agent_container_name)
        if not container:
            logger.error(
                f"No container found for name: {
                         agent_container_name}"
            )
            raise AgentContainerError("Failed to run agent in container")

        container_agent_config_file_path = (
            self._copy_and_get_container_agent_config_path(
                agent_container_name, player_name, activity_id, agent_config_path
            )
        )

        container_transcript_manager_config_file_path = (
            self._copy_and_get_container_transcript_manager_config_path(
                agent_container_name,
                player_name,
                activity_id,
                transcript_manager_config_file_path,
            )
        )

        container_log_file_posix_path = (
            self._get_container_output_redirect_log_posix_path(player_name, activity_id)
        )

        sentient_llm_config_json_b64 = self.serialize_llm_config_to_b64(
            sentient_llm_config
        )

        command = [
            f". /app/venv/bin/activate && "
            f"python /sent_lib/agent_loader/user_agent_loader.py "
            f"--controller_container_name {controller_container_name} "
            f"--campaign_name {campaign_name} "
            f"--player_name {player_name} "
            f"--activity_id {activity_id} "
            f"--module_path {agent_module_path} "
            f"--class_name {agent_class_name} "
            f"--agent_config_path {container_agent_config_file_path} "
            f"--sentient_llm_config_json_b64 {sentient_llm_config_json_b64} "
            f"--transcript_manager_config_path {
                container_transcript_manager_config_file_path} "
        ]
        redirected_command = self._wrap_redirection_to_container_exec_command(
            command, container_log_file_posix_path
        )
        self._run_start_agent_command_in_container(
            agent_container_name,
            player_name,
            str(container_log_file_posix_path),
            redirected_command,
            max_retries=max_retries,
        )

    def _copy_and_get_container_agent_config_path(
        self, agent_container_name, player_name, activity_id, agent_config_path
    ):
        container_agent_config_file_name = (
            f"{player_name}_{activity_id}_agent_config.yaml"
        )
        if not self.copy_to_container(
            agent_container_name,
            agent_config_path,
            "/tmp/",
            container_agent_config_file_name,
        ):
            logger.error("Failed to copy agent config to container")
            raise AgentContainerError("Failed to copy agent config to container")

        container_agent_config_file_path = f"/tmp/{
            container_agent_config_file_name}"
        return container_agent_config_file_path

    def _copy_and_get_container_transcript_manager_config_path(
        self,
        agent_container_name,
        player_name,
        activity_id,
        transcript_config_file_path,
    ):
        transcript_manager_config_file_name = f"{
            player_name}_{activity_id}_transcript_config.yaml"
        container_dir = "/tmp/"
        if not self.copy_to_container(
            agent_container_name,
            transcript_config_file_path,
            container_dir,
            transcript_manager_config_file_name,
        ):
            logger.error("Failed to copy transcript config to container")
            raise AgentContainerError("Failed to copy transcript config to container")
        container_transcript_manager_config_file_path = str(
            PurePosixPath.joinpath(
                PurePosixPath(container_dir), transcript_manager_config_file_name
            )
        )
        return container_transcript_manager_config_file_path

    def _get_container_output_redirect_log_posix_path(
        self, player_name, activity_id
    ) -> PurePosixPath:
        """
        Get the path to the log file in the container

        Args:
            player_name (str): The name of the player
            activity_id (str): The ID of the activity

        Returns:
            PurePosixPath: The PurePosixPath based path to the log file in the container

        """
        return PurePosixPath(
            f"/tmp/sentient_agent_logs/{player_name}_{activity_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        )

    def _run_start_agent_command_in_container(
        self, agent_container_name, player_name, log_file_path, command, max_retries=1
    ):
        try:
            exec_id = self._run_command_in_container(
                agent_container_name, command, max_retries=max_retries
            )
            self.executions[player_name] = {
                "container_name": agent_container_name,
                "log_file_path": log_file_path,
                "execution_id": exec_id,
            }
        except:
            logger.error(
                f"Failed to run player agent in container: {
                         agent_container_name}"
            )
            raise

    def _run_command_in_container(self, container_name, command, max_retries=1):

        container: Container = self.containers.get(container_name)

        # First, check if the container is running
        container.reload()
        if container.status != "running":
            logger.error(
                f"Container {container_name} is not running. Status: {
                    container.status}"
            )
            raise AgentContainerError(f"Container {container_name} is not running")

        for attempt in range(max_retries):
            try:
                logger.info(f"running command : {" ".join(command)}")
                exec_command = self.client.api.exec_create(container.id, command)
                self.client.api.exec_start(exec_command["Id"], detach=True)
                return exec_command["Id"]
            except APIError as e:
                logger.error(f"Attempt failed to start agent in container : {str(e)}")
                if attempt == max_retries - 1:
                    logger.error(
                        f"All {max_retries} attempts to start agent have failed."
                    )
                    raise e
                time.sleep(2**attempt)
        else:
            logger.error(
                f"Failed to start agent in container {
                         container_name}"
            )
            raise AgentContainerError(
                f"Failed to start agent in container {container_name}"
            )
        # run agent in container

    def is_agent_running(self, player_name):
        execution = self.executions.get(player_name, None)
        if not execution and not execution.get("execution_id", None) is None:
            logger.error(f"No execution found for player: {player_name}")
            return False
        exec_info = self.client.api.exec_inspect(exec_id=execution["execution_id"])
        if exec_info["Running"]:
            return True
        return False

    def tail_agent_logs(self, player_name, lines=10):
        execution_info = self.executions.get(player_name, None)
        if not execution_info:
            logger.error(f"No execution found for player: {player_name}")
            return None
        container_name = execution_info["container_name"]
        container = self.containers.get(execution_info["container_name"])
        log_file_path = execution_info["log_file_path"]

        try:
            exec_result = container.exec_run(f"tail -n {lines} {log_file_path}")
            if exec_result.exit_code == 0 or exec_result.exit_code == None:
                return exec_result.output.decode("utf-8")
            else:
                logger.error(
                    f"Failed to tail logs in container {
                             container_name}. Exit code: {exec_result.exit_code}"
                )
                logger.error(
                    f"Error output: {
                             exec_result.output.decode('utf-8')}"
                )
                raise AgentContainerError(
                    f"Failed to tail logs for  {player_name}'s agent"
                )
        except APIError as e:
            logger.error(
                f"Error tailing logs for container {
                         container_name}: {str(e)}"
            )
            raise AgentContainerError(f"Failed to tail logs for  {player_name}'s agent")

    def stream_agent_log_file(self, player_name):
        execution_info = self.executions.get(player_name, None)
        if not execution_info:
            logger.error(f"No execution found for player: {player_name}")
            return None
        container_name = execution_info["container_name"]
        container = self.containers.get(execution_info["container_name"])
        log_file_path = execution_info["log_file_path"]

        try:
            # Use 'tail -f' to continuously read from the log file
            cmd = f"tail -f {log_file_path}"
            stream = container.exec_run(cmd, stream=True)

            for output in stream.output:
                yield output.decode("utf-8").strip()

        except APIError as e:
            logger.error(
                f"Error streaming log file for container {
                         container_name}: {str(e)}"
            )
            raise AgentContainerError(
                f"Failed to stream logs for  {player_name}'s agent"
            )

    def _check_container_status(self, container, timeout=30):
        start_time = time.time()
        while time.time() - start_time < timeout:
            container.reload()
            if container.status == "running":
                return True
            elif container.status == "exited":
                logger.error(
                    f"Container exited with status code: {
                             container.attrs['State']['ExitCode']}"
                )
                return False
            time.sleep(1)
        logger.error("Container failed to start within the timeout period")
        return False

    def get_container_logs(self, player_name, tail=100):
        container = self.containers.get(player_name)
        if not container:
            logger.error(f"No container found for player: {player_name}")
            return None

        try:
            logs = container.logs(tail=tail, stdout=True, stderr=True).decode("utf-8")
            return logs
        except APIError as e:
            logger.error(f"Error retrieving logs for {player_name}: {str(e)}")
            return None

    def destroy_container(self, container_name, remove_image=False):
        container = self.containers.get(container_name)

        if not container:
            logger.error(f"No container found for player: {container_name}")
            return

        try:

            try:
                container = self.client.containers.get(container.id)
                container.reload()  # Refresh the container instance
                logger.info(f"Stopping container for {container_name}")
                if container.status == "running":
                    container.stop(timeout=10)
                container.remove()
                logger.info(
                    f"Container for {
                        container_name} destroyed successfully"
                )
            except docker.errors.NotFound:
                logger.info(f"Container for {container_name} not found")
            except APIError as e:
                logger.error(
                    f"Error stopping container for {
                             container_name}: {str(e)}"
                )
            if remove_image:
                if self.image:
                    try:
                        logger.info(f"Removing image for {container_name}")
                        image = self.client.images.get(self.image.id)
                        image.remove()
                        self.image = None
                        logger.info(
                            f"Image for {container_name} destroyed successfully"
                        )
                    except docker.errors.ImageNotFound:
                        logger.info(f"Image for {container_name} not found")
        except APIError as e:
            logger.error(
                f"Error stopping container for {
                         container_name}: {str(e)}"
            )

    def __del__(self):
        for container in self.containers.values():
            try:
                container.stop(timeout=10)
            except:
                pass
        self.client.close()


if __name__ == "__main__":
    try:
        wheel_path = "/home/vivek/projects/Sent-werewolf-engine/src/demo_agents/dist/sentient_demo_agents-0.1.0-py3-none-any.whl"

        builder = WheelBasedAgentImageProvider(wheel_path, force_rebuild=False)
        image = builder.get_image()

        containers_holder = AgentContainerRunner(
            "test_net",
            wheel_path,
            "sentient_campaign/demo_agents/single_agent",
            "WarewolfAgent",
            force_rebuild_agent_image=False,
        )
        containers_holder.start_container("werewolf_game_container")
        containers_holder.run_user_agent_in_container(
            "werewolf_game_container",
            "werewolf",
            "vivek",
            "act1",
            "/home/vivek/projects/Sent-werewolf-engine/src/local_activity/sentient_campaign/activity_runner/resources/agent_config.yaml",
        )

        # # containers_holder.copy_to_container("werewolf_game_container", "/home/vivek/projects/Sent-werewolf-engine/src/local_activity/sentient_campaign/activity_runner/resources/agent_config.yaml", "/tmp","agent_config.yaml")
        # containers_holder.run_agent_in_container("werewolf_game_container", "vivek","act1", "/home/vivek/projects/Sent-werewolf-engine/src/local_activity/sentient_campaign/activity_runner/resources/agent_config.yaml", "/home/vivek/projects/Sent-werewolf-engine/src/local_activity/sentient_campaign/activity_runner/resources/messenger_config.yaml")
        # for out in containers_holder.stream_agent_log_file("vivek"):
        #     print(out)
        # logger.info(f"Successfully ran container")

    except Exception as e:
        logger.error(f"Failed to build image: {str(e)}")


# /bin/sh -c '. /app/venv/bin/activate && python /sent_lib/agent_loader/agent_loader.py werewolf vivek act1 sentient_campaign/demo_agents/single_agent WarewolfAgent /tmp/vivek_act1_agent_config.yaml  > /tmp/sentient_agent_logs/vivek_act1_20241009_202301.log  2>&1'
