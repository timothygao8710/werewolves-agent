import base64
import io
import json
import logging
import os
from pathlib import PurePosixPath
import tarfile
import time
from urllib.parse import urlparse

import docker

from typing import Dict, List, Optional, Union
from docker.errors import APIError, ContainerError
from docker.models.containers import Container
import requests

from sentient_campaign.activity_runner.utils import add_console_log_handler


logger = logging.getLogger(__name__)
log_level = logging.INFO
if os.environ.get("SENTIENT_ENABLE_RUNNER_DEBUG_LOGS", "false") == "true":
    log_level = logging.DEBUG
logger = add_console_log_handler(logger, level=log_level)


class GameControllerNotRespondingError(Exception):
    """Raised when the game controller is not responding"""

    pass


class GameControllerDaemonRunner:

    def __init__(
        self,
        docker_client,
        campaign_name,
        activity_id,
        health_probe_port: int,
        comm_server_port: int = 8008,
    ):
        logger.debug("Initializing GameControllerDaemonRunner")
        self.docker_client: docker.DockerClient = docker_client
        self.health_probe_port = health_probe_port
        self.exposed_comm_server_port = comm_server_port
        self.internal_comm_server_port = 8008
        self.container = None
        self.game_controller_image = "public.ecr.aws/u2d4o0f0/sentient_foundation/sentient_campaign_werewolf_controller:0.3.9"
        if os.getenv("WEREWOLF_CONTROLLER_IMAGE"):
            self.game_controller_image = os.getenv("WEREWOLF_CONTROLLER_IMAGE")
        self.campaign_name = campaign_name
        self.activity_id = activity_id
        self.log_file_path = None

    def get_image(self):
        # pull image from docker
        try:
            logger.debug(
                f"Pulling game controller image: {
                         self.game_controller_image}"
            )
            self.docker_client.images.pull(self.game_controller_image)
            logger.debug(
                f"Successfully pulled game controller image: {
                    self.game_controller_image}"
            )
        except docker.errors.APIError as e:
            logger.error(f"Failed to pull game controller image: {e}")
            raise

    def copy_to_container(self, container, src, dest, dest_file_name):
        try:
            # Create a tarfile of the source
            tar_stream = io.BytesIO()
            with tarfile.open(fileobj=tar_stream, mode="w") as tar:
                if os.path.isdir(src):
                    for root, dirs, files in os.walk(src):
                        for file in files:
                            file_path = os.path.join(root, file)
                            arcname = os.path.relpath(file_path, src)
                            tar.add(file_path, arcname=arcname)
                else:
                    tar.add(src, arcname=dest_file_name)
            tar_stream.seek(0)

            # Copy the tar stream to the container
            container.put_archive(dest, tar_stream)
            logger.info(
                f"Successfully copied {src} to {
                    dest} in container {container.id}"
            )
            return True
        except APIError as e:
            logger.error(
                f"Error copying files to container {
                         container.id}: {str(e)}"
            )
            return False

    def start_container(
        self,
        network_name: str,
        container_name: str,
        environment: Dict[str, str] = {},
        cpu_count: str = 4,
        mem_limit: str = "4g",
        process_limit: int = 10000,
    ) -> Container:
        logger.info(
            f"Starting container: {container_name} for campaign: {
                self.campaign_name}, activity: {self.activity_id}"
        )
        # start the container
        exposed_ports = {
            f"{self.internal_comm_server_port}/tcp": self.exposed_comm_server_port,
            f"{self.health_probe_port}/tcp": self.health_probe_port,
        }
        try:
            logger.info(
                f"Starting game controller container with image: {
                    self.game_controller_image}"
            )
            container = self.docker_client.containers.run(
                self.game_controller_image,
                name=container_name,
                network=network_name,
                environment=environment,
                detach=True,
                cpu_count=cpu_count,
                mem_limit=mem_limit,
                ports=exposed_ports,
            )
            time.sleep(5)
            if not self._check_container_status(container):
                raise ContainerError(container, 125, "Container failed to start")

            logger.info(f"Container  {container_name} started successfully")
            self.container = container

            return container

        except docker.errors.APIError as e:
            logger.error(f"Failed to start game controller container: {e}")
            raise

    def initialize_game_controller(self, container_name, all_players: List[str]):
        if not self.container:
            logger.error("No container found")
            raise ContainerError(self.container, 125, "Container not found")
        try:

            matrix_server_url = f"http://{
                container_name}:{self.internal_comm_server_port}"
            logger.info(
                f"Initializing game controller , server url {matrix_server_url}"
            )

            command_list = [
                "python",
                "controller_loader/initialize_game.py",
                f"--activity_id={self.activity_id}",
                f"--players={','.join(all_players)}",
                f"--matrix_server_url={matrix_server_url}",
            ]

            logger.info(
                f"Initializing game controller with command: {
                        " ".join(command_list)}"
            )

            exec_result = self.container.exec_run(command_list)

            if exec_result.exit_code == 0 or exec_result.exit_code == None:
                logger.info(
                    f"Initialization output: {
                            exec_result.output.decode('utf-8')}"
                )
            else:
                logger.error(
                    f"command failed to execute {
                             container_name}. Exit code: {exec_result.exit_code}"
                )
                logger.error(
                    f"Error output: {
                             exec_result.output.decode('utf-8')}"
                )
                raise GameControllerNotRespondingError(
                    "failed to intialized game controller"
                )
        except docker.errors.APIError as e:
            logger.error(f"Failed to initialize game controller: {e}")
            raise

    def _wrap_redirection_to_container_exec_command(
        self, command: Union[str, list], posix_log_path: PurePosixPath, append=False
    ):
        redirect_operator = ">>" if append else ">"
        self.log_file_path = str(posix_log_path)
        log_dir = str(posix_log_path.parent)

        if isinstance(command, list):
            command = " ".join(command)
        wrapped_command = [
            "/bin/sh",
            "-c",
            f"mkdir -p {log_dir} && "
            f"touch {self.log_file_path } && "
            f"{command} {redirect_operator} {self.log_file_path } 2>&1",
        ]
        return wrapped_command

    def start_game_controller(
        self, all_players: List[str], player_roles_mapping: Dict[str, str] = None
    ):
        if not self.container:
            logger.error("No container found")
            raise ContainerError(self.container, 125, "Container not found")
        try:
            controller_log_path = f"/tmp/{self.activity_id}_controller_log.txt"
            self.container.exec_run(f"touch {controller_log_path}")

            command_list = [
                "python",
                "controller_loader/controller_loader.py",
                f"--campaign_name={self.campaign_name}",
                f"--activity_id={self.activity_id}",
                f"--players={','.join(all_players)}",
                f"--health_port={self.health_probe_port}",
            ]

            roles = []
            if player_roles_mapping:
                for player in all_players:
                    roles.append(player_roles_mapping.get(player))
                command_list.append(f"--player_roles={','.join(roles)}")

            redirected_command = self._wrap_redirection_to_container_exec_command(
                command_list, PurePosixPath(controller_log_path)
            )
            logger.info(
                f"Starting game controller with command: {" ".join(redirected_command)}"
            )
            self.container.exec_run(
                redirected_command,
                detach=True,
            )

        except docker.errors.APIError as e:
            logger.error(f"Failed to start game controller: {e}")
            raise

    def _check_container_status(self, container: Container, timeout: int = 30) -> bool:
        logger.info(f"Checking container status for {container.name}")
        start_time: float = time.time()
        while time.time() - start_time < timeout:
            container.reload()
            if container.status == "running":
                logger.info(f"Container {container.name} is running")
                return True
            elif container.status == "exited":
                logger.error(
                    f"Container exited with status code: {
                        container.attrs['State']['ExitCode']}"
                )
                return False
            time.sleep(1)
        logger.error("Container failed to start within the timeout period")
        return False

    def _extract_pypi_host(self, url: str) -> str:
        logger.info(f"Extracting PyPI host from URL: {url}")
        parsed_url = urlparse(url)
        host = parsed_url.hostname or ""
        logger.info(f"Extracted host: {host}")
        return host

    def get_game_state(self):
        url = f"http://localhost:{self.health_probe_port}/game_state"
        try:
            response = requests.get(url, timeout=5)
            # This will raise an HTTPError for 4xx and 5xx status codes
            response.raise_for_status()

            game_state = response.json()

            if "game_status" not in game_state:
                raise GameControllerNotRespondingError(
                    "Game state response is missing 'game_status' field"
                )

            return game_state

        except requests.HTTPError as http_err:
            # This will catch any non-200 status codes
            raise GameControllerNotRespondingError(
                f"Game controller returned unexpected status code: {
                    response.status_code}"
            ) from http_err

        except requests.RequestException as req_err:
            # This will catch network errors, timeouts, etc.
            raise GameControllerNotRespondingError(
                f"Failed to connect to game controller: {str(req_err)}"
            ) from req_err

        except ValueError as json_err:
            # This will catch JSON decoding errors
            raise GameControllerNotRespondingError(
                f"Invalid response from game controller: {str(json_err)}"
            ) from json_err

    def check_if_game_is_running(self):
        url = f"http://localhost:{self.health_probe_port}/health"
        logger.debug(f"Checking if game is running at {url}")
        try:
            response = requests.get(url, timeout=5)
            # This will raise an HTTPError for 4xx and 5xx status codes
            response.raise_for_status()

            data = response.json()
            game_status = data.get("game_status")
            logger.debug(f"Game status: {game_status}")

            if game_status in ["initializing", "running"]:
                logger.debug("Game is currently running")
                return True
            elif game_status in ["ended", "terminated", "aborted"]:
                logger.debug("Game has ended or terminated")
                return False
            else:
                logger.warning(f"Unexpected game status: {game_status}")
                raise GameControllerNotRespondingError(
                    f"Unexpected game status: {game_status}"
                )

        except requests.HTTPError as http_err:
            # This will catch any non-200 status codes
            logger.error(f"HTTP error occurred: {http_err}")
            raise GameControllerNotRespondingError(
                f"Game controller returned unexpected status code: {
                    response.status_code}"
            ) from http_err

        except requests.RequestException as req_err:
            # This will catch network errors, timeouts, etc.
            logger.error(f"Request exception occurred: {req_err}")
            raise GameControllerNotRespondingError(
                f"Failed to connect to game controller: {str(req_err)}"
            ) from req_err

        except ValueError as json_err:
            # This will catch JSON decoding errors
            logger.error(f"JSON decoding error occurred: {json_err}")
            raise GameControllerNotRespondingError(
                f"Invalid response from game controller: {str(json_err)}"
            ) from json_err

    def destroy_container(self) -> None:
        if self.container:
            try:
                logger.info(f"Stopping container {self.container.name}")
                self.container.reload()
                if self.container.status == "running":
                    self.container.stop(timeout=10)
                self.container.remove()
                logger.info(f"Container stopped successfully")
            except APIError as e:
                logger.error(f"Error stopping container: {str(e)}")

    def get_container_logs(self, tail: int = 100) -> Optional[str]:
        if not self.container:
            logger.error("No container found")
            return None

        try:
            logger.info(f"Retrieving logs for container {self.container.name}")
            logs: str = self.container.logs(tail=tail, stdout=True, stderr=True).decode(
                "utf-8"
            )
            return logs
        except APIError as e:
            logger.error(f"Error retrieving logs: {str(e)}")
            return None

    def copy_game_log_file_from_container(self, host_file_path):
        self.container.reload()
        stream, _ = self.container.get_archive(self.log_file_path)
        try:
            # Ensure the local directory exists
            os.makedirs(os.path.dirname(host_file_path), exist_ok=True)

            # Open the local file for writing
            with open(host_file_path, "wb") as local_file:
                # Stream and write the file content
                for chunk in stream:
                    local_file.write(chunk)

            print(
                f"File successfully streamed from container and saved to {
                  host_file_path}"
            )
            return True

        except docker.errors.NotFound:
            print(f"Container {self.container.id} not found")
        except docker.errors.APIError as e:
            print(f"Error accessing the Docker API: {e}")
        except IOError as e:
            print(f"I/O error({e.errno}): {e.strerror}")
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
        return False

    def __del__(self) -> None:
        if self.container:
            try:
                logger.info(
                    f"Stopping container {
                            self.container.name} in destructor"
                )
                self.container.stop(timeout=10)
            except:
                pass
        self.docker_client.close()
        logger.info("Docker client closed")
