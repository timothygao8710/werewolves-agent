from enum import Enum
import json
import socket

from termcolor import colored
from sentient_campaign.activity_runner._agent_daemon_runner import (
    AgentContainerRunner,
    AgentImageProvider,
    WheelBasedAgentImageProvider,
)
from sentient_campaign.activity_runner._game_controller_daemon_runner import (
    GameControllerDaemonRunner,
)
from collections import defaultdict
import logging
from abc import ABC, abstractmethod
import os
import random
import tempfile
import threading
import time
import traceback
from types import MappingProxyType
from typing import List, Tuple, Dict
import docker
from docker.errors import APIError, ContainerError
from pydantic import BaseModel
import requests
import yaml
from copy import deepcopy

from sentient_campaign.activity_runner.utils import add_console_log_handler


# Configure logging

logger = logging.getLogger("activity_runner")
log_level = logging.INFO
if os.environ.get("SENTIENT_ENABLE_RUNNER_DEBUG_LOGS", "false") == "true":
    log_level = logging.DEBUG
logger = add_console_log_handler(logger, level=log_level)


class PlayerAgentConfig(BaseModel):
    """
    PlayerAgentConfig is a configuration model for a player agent in the Sent-werewolf-engine.

    Attributes:
        player_name (str): The name of the player.
        agent_wheel_path (str): The file path to the agent's wheel package.
        module_path (str): The module path where the agent class is located.
        agent_class_name (str): The name of the agent class.
        agent_config_file_path (str): The file path to the agent's configuration file.
    """

    player_name: str
    agent_wheel_path: str
    module_path: str
    agent_class_name: str
    agent_config_file_path: str


class PlayerAgentInfra:

    def __init__(
        self,
        image_provider: AgentImageProvider,
        container_runner: AgentContainerRunner,
        container_name: str,
    ):
        self.image_provider = image_provider
        self.container_runner = container_runner
        self.container_name = container_name


class SentientWerewolfRoles(str, Enum):
    WOLF = "wolf"
    SEER = "seer"
    DOCTOR = "doctor"
    VILLAGER = "villager"


class CampaignActivityRunner(ABC):

    def __init__(self, campaign_name):
        self.campaign_name = campaign_name

    @abstractmethod
    def run_locally(self, agent_config: PlayerAgentConfig) -> str:
        """Run the agent locally
        Args:
            agent_config (PlayerAgentConfig): Configuration for the agent
            Returns:
                activity_id (str): The activity id
        """
        pass

    @abstractmethod
    def run_with_your_agents(self, agents_config: List[PlayerAgentConfig]) -> str:
        """Run the agent in the server
        Args:
            agent_config (List[PlayerAgentConfig]): Configuration for the agents
            Returns:
                activity_id (str): The activity id
        """
        pass


def busy_wait(seconds):
    start = time.process_time()
    # Busy wait until desired CPU time has elapsed
    while (time.process_time() - start) < seconds:
        pass


class WerewolfCampaignActivityRunner(CampaignActivityRunner):
    """
    A class for running Werewolf campaign activities in a local development environment.

    This class manages the setup, execution, and cleanup of Werewolf game activities,
    including handling Docker containers for agents and the game controller.

    Attributes:
        TRANSCRIPT_MANAGER_CONFIG_PATH (str): Constant for transcript manager config path.
        AGENT_CONFIG_PATH (str): Constant for agent config path.
        STANDARD_AGENT_NAME (list): List of predefined agent names from various cultures.

    Methods:
        run_locally(player_agent_info,players_sentient_llm_api_keys,path_to_final_transcript_dump, force_rebuild_agent_image):
            Runs a local Werewolf campaign activity.
        run_in_server(agents_config):
            Not implemented. Raises NotImplementedError.

    Usage:
        runner = WerewolfCampaignActivityRunner()
        activity_id = runner.run_locally(player_agent_info, path_to_transcripts)
    """

    TRANSCRIPT_MANAGER_CONFIG_PATH: str = "transcript_manager_config_path"
    AGENT_CONFIG_PATH: str = "agent_config_path"
    STANDARD_PLAYER_NAMES = [
        # Japanese names
        "Akira",
        "Yuki",
        "Haruto",
        # Chinese names
        "Wei",
        "Ling",
        "Jian",
        # American names
        "John",
        "Emma",
        "Michael",
        # European names
        "Sophie",
        "Luca",
        "Astrid",
        "Klaus",
        "Elise",
        "Fredrik",
        "Helga",
        "Pietro",
        "Ingrid",
        # Indian names (including more modern ones)
        "Arjun",
        "Abhimanyu",
        "vihaan",
        "Ananya",
        "Aarav",
        "Kiara",
        "Ramesh",
        "Myra",
        # Mixed
        "Chen",
        "Emily",
        "Lars",
        "Olivia",
        "Hiroshi",
        "Anna",
    ]

    def __init__(self, activity_id=None, com_server_port=8008) -> None:
        """Entry point class for agents to register themselves for campaign"""
        super().__init__("werewolf")
        if not activity_id:
            self._activity_id = self._generate_activity_id()
        else:
            self._activity_id = activity_id
        self._network_name = f"{self._activity_id}_sentient_campaign_network"
        self.controller_health_port = self._get_available_port()
        # self._get_available_port(start_range=13000, end_range=14000)
        self.com_server_port = com_server_port
        self.docker_client = docker.from_env()
        self.game_controller_daemon_runner = None
        self.stop_flag = threading.Event()
        self.user_agent_log_thread = None
        logger.debug(
            f"Initialized WerewolfCampaignActivityRunner with activity_id: {self._activity_id} and network_name: {self._network_name} and controller_health_port: {self.controller_health_port}"
        )

    @staticmethod
    def _generate_activity_id() -> str:
        return f"{int(time.time())}_{''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=3))}"

    def _wait_for_server(self, host, port, timeout=240):
        start_time = time.monotonic()
        while True:
            try:
                with socket.create_connection((host, port), timeout=1):
                    print(f"Server is up and running on {host}:{port}")
                    return True
            except (socket.timeout, ConnectionRefusedError):
                if time.monotonic() - start_time > timeout:
                    print(
                        f"Timeout: Server did not start within {
                          timeout} seconds"
                    )
                    return False
            time.sleep(1)

    def _start_game_controller_container(
        self,
        container_name,
        all_players: List[str],
        environment: Dict[str, str] = {},
        cpu_count=2,
        mem_limit="2g",
        process_limit=10000,
    ) -> GameControllerDaemonRunner:

        if os.environ.get("SENTIENT_WEREWOLF_ALLOW_FAILURE", "false") == "true":
            environment["SENTIENT_WEREWOLF_ALLOW_FAILURE"] = "true"
            environment["SENTIENT_WEREWOLF_FAILABLE_AGENTS_COUNT"] = os.environ.get(
                "SENTIENT_WEREWOLF_FAILABLE_AGENTS_COUNT", 2
            )

        try:
            game_controller_deamon_runner = GameControllerDaemonRunner(
                self.docker_client,
                self.campaign_name,
                self._activity_id,
                self.controller_health_port,
                self.com_server_port,
            )
            game_controller_deamon_runner.start_container(
                self._network_name,
                container_name,
                environment=environment,
                cpu_count=cpu_count,
                mem_limit=mem_limit,
                process_limit=process_limit,
            )

            # Wait for the game controller to start

            self._wait_for_server("localhost", self.com_server_port)

            logger.info(
                f"comm server has started on port {
                        self.com_server_port}"
            )
            busy_wait(3)
            time.sleep(3)
            game_controller_deamon_runner.initialize_game_controller(
                container_name, all_players
            )
            time.sleep(5)
            return game_controller_deamon_runner
        except Exception as e:
            logger.error(f"Failed to start game controller container: {e}")
            raise
        # pull image from docker

    def _get_available_port(self, start_range=11000, end_range=12000):
        while True:
            port = random.randint(start_range, end_range)
            if self._is_port_available(port):
                return port

    def _is_port_available(self, port):
        import socket

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            return s.connect_ex(("localhost", port)) != 0

    def _get_sentient_llm_config(self, players_sentient_llm_api_keys: List[str]):

        model_name = os.environ.get("SENTIENT_DEFAULT_LLM_MODEL_NAME")
        if model_name is None or model_name == "":
            model_name = "Llama31-70B-Instruct"
        base_url = os.environ.get("SENTIENT_DEFAULT_LLM_BASE_URL")
        if base_url is None or base_url == "":
            base_url = "https://hp3hebj84f.us-west-2.awsapprunner.com"

        config_list = []
        for key in players_sentient_llm_api_keys:
            config_list.append(
                {"llm_model_name": model_name, "api_key": key, "llm_base_url": base_url}
            )

        return {"config_list": config_list}

    def run_against_standard_agents(
        self,
        player_agent_info: PlayerAgentConfig,
        players_sentient_llm_api_keys: List[str],
        path_to_final_transcript_dump: str,
        force_rebuild_agent_image=True,
    ) -> Dict:
        return self.run_locally(
            player_agent_info,
            players_sentient_llm_api_keys,
            path_to_final_transcript_dump=path_to_final_transcript_dump,
            force_rebuild_agent_image=force_rebuild_agent_image,
        )

    def run_locally(
        self,
        player_agent_info: PlayerAgentConfig,
        players_sentient_llm_api_keys: List[str],
        path_to_final_transcript_dump: str,
        force_rebuild_agent_image=True,
    ) -> Dict:
        """
        player_agent_info: PlayerAgentConfig: Configuration for the player agent
        players_sentient_llm_api_keys: List[str], List of sentient LLM API keys for the players
        path_to_final_transcript_dump: str: Path to dump the final transcripts
        force_rebuild_agent_image: bool: Force rebuild the agent
        """

        assert isinstance(player_agent_info, PlayerAgentConfig)
        assert isinstance(players_sentient_llm_api_keys, list)
        assert all(isinstance(key, str) for key in players_sentient_llm_api_keys)
        assert len(players_sentient_llm_api_keys) > 0
        if not path_to_final_transcript_dump is None:
            assert isinstance(path_to_final_transcript_dump, str)
            if not os.path.exists(path_to_final_transcript_dump):
                raise ValueError(
                    f"please create transcript dump directory : {
                                 path_to_final_transcript_dump}"
                )

        sentient_llm_config = self._get_sentient_llm_config(
            players_sentient_llm_api_keys
        )

        logger.info(f"llm config for agents {sentient_llm_config}")

        user_agent_log_thread = None
        logger.info(
            f"Starting Werewolf Campaign local Activity for {
                player_agent_info.player_name}"
        )

        agent_image_name = f"sentient_common_werewolf_agents_image"

        agent_container_name = f"sentient_{
            self._activity_id}_werewolf_agents_container"
        player_agents_infra = {}
        try:
            if self.game_controller_daemon_runner:
                raise Exception("Game controller already running")
            # Create docker network
            docker_client = self.docker_client
            self._create_docker_network(docker_client)

            # Select users
            sentient_players = self._select_sentient_players_for_game(player_agent_info)

            # start game container
            controller_container_name = (
                f"{self._activity_id}_sentient_werewolf_controller"
            )

            all_players = [player_agent_info.player_name] + sentient_players

            self.game_controller_daemon_runner = self._start_game_controller_container(
                controller_container_name, all_players
            )

            with tempfile.TemporaryDirectory() as working_directory:

                # Start agent container

                agent_image = WheelBasedAgentImageProvider(
                    self.docker_client,
                    agent_image_name,
                    player_agent_info.agent_wheel_path,
                    force_rebuild_agent_image,
                )
                agent_container_runner: AgentContainerRunner = (
                    self._create_agent_container(
                        agent_container_name,
                        agent_image,
                        cpu_count=3,
                        mem_limit="4g",
                        process_limit=20000,
                    )
                )

                busy_wait(2)
                for sentient_player in sentient_players:
                    player_agents_infra[sentient_player] = PlayerAgentInfra(
                        image_provider=agent_image,
                        container_runner=agent_container_runner,
                        container_name=agent_container_name,
                    )
                    agent_container_runner.run_sentient_default_agent_in_container(
                        sentient_llm_config,
                        agent_container_name,
                        self.campaign_name,
                        sentient_player,
                        self._activity_id,
                        self._generate_transcript_manager_config_path(
                            working_directory, sentient_player
                        ),
                        controller_container_name,
                    )

                # Start users agent in the container
                player_agents_infra[player_agent_info.player_name] = PlayerAgentInfra(
                    image_provider=agent_image,
                    container_runner=agent_container_runner,
                    container_name=agent_container_name,
                )
                agent_container_runner.run_user_agent_in_container(
                    sentient_llm_config,
                    agent_container_name,
                    player_agent_info.module_path,
                    player_agent_info.agent_class_name,
                    self.campaign_name,
                    player_agent_info.player_name,
                    self._activity_id,
                    player_agent_info.agent_config_file_path,
                    self._generate_transcript_manager_config_path(
                        working_directory, player_agent_info.player_name
                    ),
                    controller_container_name,
                )
                user_agent_log_thread = threading.Thread(
                    target=self._stream_logs_thread,
                    args=(
                        player_agent_info.player_name,
                        player_agents_infra[player_agent_info.player_name],
                    ),
                )

                self.game_controller_daemon_runner.start_game_controller(all_players)
                self._print_werewolf_started_message()
                user_agent_log_thread.start()
                game_stats = self._monitor_game_and_save_result(
                    player_agents_infra, path_to_final_transcript_dump
                )
                logger.info("Werewolf Campaign Activity completed successfully")
                return game_stats

        except KeyboardInterrupt:
            logger.info("Werewolf Campaign Activity interrupted")
        except Exception as e:
            logger.error(f"Werewolf Campaign Activity failed: {e}")
            logger.error(traceback.format_exc())

        finally:
            # Cleanup code
            self.stop_flag.set()  # Signal the thread to stop
            if (not user_agent_log_thread is None) and user_agent_log_thread.is_alive():
                user_agent_log_thread.join(timeout=5)
            self._clean_up_resource(docker_client, player_agents_infra)

    def _copy_game_transcripts_and_logs(
        self,
        player_agents_infra: Dict[str, PlayerAgentInfra],
        path_to_final_transcript_dump,
        copy_transcripts=True,
    ):
        transcrip_paths = {}
        log_paths = {}
        game_controller_log_path = None
        try:
            game_controller_log_path = os.path.join(
                path_to_final_transcript_dump,
                f"{self._activity_id}_game_controller_log.txt",
            )
            self.game_controller_daemon_runner.copy_game_log_file_from_container(
                game_controller_log_path
            )
        except:
            logger.error("Error copying game controller log file")

        for player in player_agents_infra:
            try:
                if copy_transcripts:
                    host_transcript_file_path = os.path.join(
                        path_to_final_transcript_dump,
                        f"{player}_{self._activity_id}_transcript.jsonl",
                    )

                    container_transcript_file_path = (
                        self._get_transcript_path_for_player_in_container(player)
                    )

                    logger.debug(f"Copying transcript for user {player}")
                    logger.debug(
                        f"Host transcript file path: {
                                host_transcript_file_path}"
                    )
                    logger.debug(
                        f"Container transcript file path: {
                            container_transcript_file_path}"
                    )

                    player_agents_infra[
                        player
                    ].container_runner.copy_file_from_container(
                        player_agents_infra[player].container_name,
                        container_transcript_file_path,
                        host_transcript_file_path,
                    )
                    transcrip_paths[player] = host_transcript_file_path

                host_log_file_path = os.path.join(
                    path_to_final_transcript_dump,
                    f"{player}_{self._activity_id}_log.txt",
                )

                player_agents_infra[
                    player
                ].container_runner.copy_agent_log_file_from_container(
                    player, host_log_file_path
                )
                log_paths[player] = host_log_file_path
            except Exception as e:
                logger.error(
                    f"Error copying transcript and logs for user {player}: {e}"
                )

        return transcrip_paths, log_paths, game_controller_log_path

    def _stream_logs_thread(self, player_name, player_agent_infra: PlayerAgentInfra):
        try:
            agent_container_runner = player_agent_infra.container_runner
            for line in agent_container_runner.stream_agent_log_file(player_name):
                if self.stop_flag.is_set():
                    break
                logger.info(f"{player_name}: {line}")
        except Exception as e:
            logger.error(f"Error in log streaming thread: {e}")

    def _print_werewolf_started_message(self):
        werewolf = """⠀⠀⠀⠀⠀⠀⠀⢀⣤⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            ⠀⠀⠀⠀⣰⡆⠀⣿⡟⣁⣀⠀⠀⠀⠸⣷⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            ⠀⠀⠀⠀⠹⣿⣶⣿⣿⠟⠙⠓⠀⠀⠀⠻⣿⣿⣿⣿⣿⡿⣿⣿⣿⣿⠃⠀⠀⠀
            ⠀⠀⠀⠀⠀⠈⢻⣿⣿⡄⠀⢀⣴⣶⣿⣿⣿⣿⣿⣿⠏⢀⠙⠋⠀⠉⠀⠀⠀⠀
            ⠀⠀⠀⠀⠀⠀⠸⣿⣿⣷⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣷⣾⡿⠀⠀⠀⠀⠀
            ⠀⠀⠀⣴⡀⠀⠀⠛⠛⠛⠻⣿⣿⣿⣿⣿⣿⣿⡿⠋⠉⠀⠀⠀⣀⣀⣀⠀⠀⠀
            ⠀⠀⢰⣿⣇⣠⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⢿⣿⣦⣀⠀⣴⣿⣿⠋⠉⠀⠀⠀
            ⠀⠀⣈⣿⣿⣿⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⠇⠈⢿⣿⣿⣿⡿⠿⣿⣿⠿⣷⡄⠀
            ⠀⠀⠻⣿⣿⣿⣧⡀⠀⣠⣾⣿⣿⣿⣿⣿⣦⣤⣀⠉⠉⠀⠀⠀⠘⣿⠀⠘⠃⠀
            ⠀⠀⠀⠈⠉⠛⠻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣆⠀⠀⠀⠀⠋⠀⠀⠀⠀
            ⠀⠀⠀⠀⠀⣀⠀⠀⣿⣿⣿⣿⡟⠀⠀⠈⠻⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀
            ⠀⠀⠀⢠⣾⣿⣿⣶⣿⣿⣿⠏⠀⠀⠀⢀⣴⣿⠿⠿⠿⠟⠀⠀⠀⠀⠀⠀⠀⠀
            ⠀⠀⢠⣿⣿⣿⠉⠙⠛⠋⠁⠀⠀⠀⢠⣾⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            ⠀⠀⣾⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
            ⠀⠐⠛⠛⠛⠛⠓⠀⠀⠀⠀⠀⠀⠀⠈⠛⠛⠛⠛⠂⠀⠀"""
        for line in werewolf.split("\n"):
            print(colored(line, "red"))
            time.sleep(0.05)
        print(
            "werewolf game started, you can now open the game in chrome browser using following"
        )
        url = "https://hydrogen.sentient.xyz/#/login"
        print("\n\t" + colored(url, "cyan") + "\n")
        busy_wait(3)
        time.sleep(3)

    def _monitor_game(
        self,
        all_players_infra: Dict[str, PlayerAgentInfra],
        path_to_transcripts,
        ignore_agent_failure=False,
    ):

        check_interval = 20  # Check game status every 10 seconds
        agent_failures = {}
        while True:
            time.sleep(check_interval)
            if not self.game_controller_daemon_runner.check_if_game_is_running():
                self.stop_flag.set()
                logger.info("Game has ended")
                game_state = self.game_controller_daemon_runner.get_game_state()
                logger.info(f"Game state: {game_state}")
                player_errors:Dict = game_state.get("player_errors",{})
                for key in agent_failures.keys():
                    agent_error_list = agent_failures.get(key,{
                        "error_list":[]
                    })["error_list"]
                    for player_name in player_errors.keys():
                        player_error = player_errors.get(player_name)
                        error_list: List = player_error.get("error_list",[])
                        error_list.extend(agent_error_list)
                return game_state

            for player_name in all_players_infra:
                agent_container_runner: AgentContainerRunner = all_players_infra[
                    player_name
                ].container_runner
                if (
                    player_name not in agent_failures
                    and not agent_container_runner.is_agent_running(player_name)
                ):
                    self.stop_flag.set()
                    logger.error(f"Agent for player {player_name} has stopped")
                    agent_error_tail = agent_container_runner.tail_agent_logs(
                        player_name, 50
                    )
                    logger.error(
                        f"here is the last 100 lines of agent log , {
                                 agent_container_runner.tail_agent_logs(player_name, 50)}"
                    )
                    logger.error(
                        f"Copying player {
                                 player_name}'s agent log to transcript folder"
                    )
                    try:
                        agent_container_runner.copy_agent_log_file_from_container(
                            player_name,
                            f"{path_to_transcripts}/{self.campaign_name}_{self._activity_id}_{player_name}_agent_log.txt",
                        )
                    except Exception as e:
                        logger.error(
                            f"Error copying agent log file for player {player_name}: {e}"
                        )
                    if not ignore_agent_failure:
                        return {
                            "activity_id": self._activity_id,
                            "players": list(all_players_infra.keys()),
                            "game_status": "terminated",
                            "player_errors": {},
                            "failure_game_stats": {
                                "faulty_players": [player_name],
                                "termination_code": "AGENT_FAILURE",
                                "termination_reason": f"player agent {player_name} exited",
                                "traceback": json.dumps(str(agent_error_tail[:-1000])),
                            },
                        }
                    else:
                        agent_failures[player_name] = {
                            "error_list": [json.dumps(str(agent_error_tail[:-1000]))],
                            "error_count": 1,
                        }
            if os.environ.get("SENTIENT_WEREWOLF_ALLOW_FAILURE","false") == "true" and len(agent_failures.keys()) > int(
                os.environ.get("SENTIENT_WEREWOLF_FAILABLE_AGENTS_COUNT", 2)
            ):
                return {
                    "activity_id": self._activity_id,
                    "players": list(all_players_infra.keys()),
                    "game_status": "aborted",
                    "player_errors": agent_failures,
                    "failure_game_stats": {
                        "faulty_players": list(agent_failures.keys()),
                        "termination_code": "MULTI_AGENT_FAILURE",
                        "termination_reason": f"players agent's  exited , failed players {list(agent_failures.keys())}",
                        "traceback": json.dumps(
                            {
                                agent_name: json.dumps(agent_failures[agent_name])
                                for agent_name in agent_failures.keys()
                            }
                        ),
                    },
                }

            logger.info(f"game is going on ...")
        self.stop_flag.set()

    def _clean_up_resource(
        self, docker_client, all_players_agent_infra: Dict[str, PlayerAgentInfra]
    ):
        logger.info("Cleaning up resources...")

        try:
            for player_name, player_agent_infra in all_players_agent_infra.items():
                agent_infra: PlayerAgentInfra = player_agent_infra
                try:
                    agent_infra.container_runner.destroy_container(
                        agent_infra.container_name
                    )
                except Exception as e:
                    logger.error(f"Error destroying agent container: {e}")

            if self.game_controller_daemon_runner:
                try:
                    logger.info("Destroying controller daemon container")
                    self.game_controller_daemon_runner.destroy_container()
                except Exception as e:
                    logger.error(f"Error destroying controller daemon container: {e}")
            if docker_client:
                try:
                    logger.info(
                        f"Removing Docker network: {
                                self._network_name}"
                    )
                    docker_client.networks.get(self._network_name).remove()
                except Exception as e:
                    logger.error(f"Error removing Docker network: {e}")

        except Exception as e:
            logger.error(f"Error during cleanup: {e}")

    def _create_agent_container(
        self,
        agent_container_name,
        agent_image_provider: AgentImageProvider,
        environment={},
        cpu_count=1,
        mem_limit="2g",
        process_limit=10000,
    ):
        try:
            agent_container = AgentContainerRunner(
                self.docker_client, self._network_name, agent_image_provider
            )
            agent_container.start_container(
                agent_container_name,
                environment=environment,
                cpu_count=cpu_count,
                mem_limit=mem_limit,
                process_limit=process_limit,
            )
            logger.info(f"Started agent container: {agent_container_name}")
            return agent_container
        except Exception as e:
            logger.error(f"Failed to start agent container: {e}")
            raise

    def _generate_transcript_manager_config_path(self, tmpdir, player: str):
        transcript_manager_config_path = os.path.join(
            tmpdir,
            f"{player}_{
                self._activity_id}_transcript_manager_config.yaml",
        )
        with open(transcript_manager_config_path, "w") as f:
            f.write(
                yaml.dump(
                    {
                        "type": "file",
                        "file_path": self._get_transcript_path_for_player_in_container(
                            player
                        ),
                    }
                )
            )
        logger.debug(
            f"Generated transcript manager config for user {
                player} at {transcript_manager_config_path}"
        )
        return transcript_manager_config_path

    def _get_transcript_path_for_player_in_container(self, player):
        return f"/tmp/sentient_agent_transcripts/{player}_{self._activity_id}_transcript.jsonl"

    def _select_sentient_players_for_game(
        self, agent_config: PlayerAgentConfig
    ) -> List[str]:
        try:
            standerd_agents = deepcopy(self.STANDARD_PLAYER_NAMES)
            if agent_config.player_name in standerd_agents:
                standerd_agents.remove(agent_config.player_name)
            additional_players = random.sample(
                standerd_agents,
                os.environ.get("SENTIENT_WEREWOLF_GAME_DEFAULT_PLAYERS_COUNT", 7),
            )
            # additional_users = ['Aarav','Chen','Ingrid','Arjun','Luca','Myra']
            logger.info(f"additional players: {', '.join(additional_players)}")
            return additional_players
        except ValueError as e:
            logger.error(f"Failed to select users: {e}")
            raise

    def _create_docker_network(self, docker_client: docker.DockerClient):
        try:
            self.network = docker_client.networks.create(
                name=self._network_name, driver="bridge"
            )
            logger.info(f"Created Docker network: {self._network_name}")
        except docker.errors.APIError as e:
            logger.error(f"Failed to create Docker network: {e}")

            raise

    def run_with_your_agents(
        self,
        agents_config: List[PlayerAgentConfig],
        players_sentient_llm_api_keys: List[str],
        path_to_final_transcript_dump: str,
        player_roles: Dict[str, SentientWerewolfRoles] = None,
        force_rebuild_agent_images=True,
    ) -> Dict:
        """
        This method accepts agent config for seven agents and runs , creates seven containers for each of them to run the werewolf game.
        agents_config: List[PlayerAgentConfig]: Configuration for the player agents.
        players_sentient_llm_api_keys: List[str]: List of sentient LLM API keys for the players.
        path_to_final_transcript_dump: str: Path to dump the final transcripts.
        player_roles: Dict[str, SentientWerewolfRoles]: Dictionary of player roles.
        force_rebuild_agent_images: bool: Force rebuild the agents.
        """
        logger.warning(
            "run_in_server , this method will drain a lot of your cpu and memory, please use it with caution !! "
        )
        self._validate_parameters(
            agents_config,
            players_sentient_llm_api_keys,
            path_to_final_transcript_dump,
            player_roles,
        )

        sentient_llm_config = self._get_sentient_llm_config(
            players_sentient_llm_api_keys
        )
        logger.info(f"llm config for agents {sentient_llm_config}")
        docker_client = self.docker_client
        try:
            if self.game_controller_daemon_runner:
                raise Exception("Game controller already running")
            # Create docker network
            self._create_docker_network(docker_client)

            logger.info("Starting Werewolf Campaign Activity ")
            all_players = [agent.player_name for agent in agents_config]
            all_players_agent_infra: Dict[str, PlayerAgentInfra] = {}
            if len(all_players) > len(set(all_players)):
                raise ValueError(
                    f"player names should be unique, given player names {all_players}"
                )

            controller_container_name = (
                f"{self._activity_id}_sentient_werewolf_controller_server"
            )
            self.game_controller_daemon_runner = self._start_game_controller_container(
                controller_container_name, all_players
            )

            with tempfile.TemporaryDirectory() as working_directory:

                for player_agent_info in agents_config:
                    agent_image_name = (
                        f"sentient_{player_agent_info.player_name}_werewolf_agent_image"
                    )
                    agent_container_name = f"{self._activity_id}_{player_agent_info.player_name}_werewolf_agent_container"
                    logger.info(f"build agent image for player {agent_image_name}")
                    agent_image_provider = WheelBasedAgentImageProvider(
                        self.docker_client,
                        agent_image_name,
                        player_agent_info.agent_wheel_path,
                        force_rebuild_agent_images,
                    )

                    logger.info(
                        f"creating agent container for player {agent_image_name}"
                    )
                    agent_container_runner = self._create_agent_container(
                        agent_container_name,
                        agent_image_provider,
                        cpu_count=1,
                        mem_limit="1g",
                        process_limit=20000,
                    )
                    all_players_agent_infra[player_agent_info.player_name] = (
                        PlayerAgentInfra(
                            image_provider=agent_image_provider,
                            container_runner=agent_container_runner,
                            container_name=agent_container_name,
                        )
                    )

                    agent_container_runner.run_user_agent_in_container(
                        sentient_llm_config,
                        agent_container_name,
                        player_agent_info.module_path,
                        player_agent_info.agent_class_name,
                        self.campaign_name,
                        player_agent_info.player_name,
                        self._activity_id,
                        player_agent_info.agent_config_file_path,
                        self._generate_transcript_manager_config_path(
                            working_directory, player_agent_info.player_name
                        ),
                        controller_container_name,
                    )

                    logger.info(
                        f"Started agent for user: {player_agent_info.player_name}"
                    )

                self.game_controller_daemon_runner.start_game_controller(
                    all_players, player_roles
                )
                self._print_werewolf_started_message()
                final_game_stats = self._monitor_game_and_save_result(
                    all_players_agent_infra, path_to_final_transcript_dump
                )

                logger.info("Werewolf Campaign Activity completed successfully")
                return final_game_stats

        except KeyboardInterrupt:
            logger.info("Werewolf Campaign Activity interrupted")
        except Exception as e:
            logger.error(f"Werewolf Campaign Activity failed: {e}")
            logger.error(traceback.format_exc())

        finally:
            # Cleanup code
            self.stop_flag.set()  # Signal the thread to stop
            self._clean_up_resource(docker_client, all_players_agent_infra)
            self.game_controller_daemon_runner = None

    def _validate_parameters(
        self,
        agents_config,
        players_sentient_llm_api_keys,
        path_to_final_transcript_dump,
        player_roles,
    ):
        logger.info("Validating agents configuration and inputs")
        assert isinstance(agents_config, list), "agents_config should be a list"
        assert all(
            isinstance(agent, PlayerAgentConfig) for agent in agents_config
        ), "Each agent in agents_config should be an instance of PlayerAgentConfig"
        assert (
            isinstance(players_sentient_llm_api_keys, list)
            and len(players_sentient_llm_api_keys) > 0
        ), "players_sentient_llm_api_keys should be a non-empty list"
        assert all(
            isinstance(key, str) for key in players_sentient_llm_api_keys
        ), "Each key in players_sentient_llm_api_keys should be a string"

        if not path_to_final_transcript_dump is None:
            assert isinstance(
                path_to_final_transcript_dump, str
            ), "path_to_final_transcript_dump should be a string"
            if not os.path.exists(path_to_final_transcript_dump):
                raise ValueError(
                    f"please create transcript dump directory : {path_to_final_transcript_dump}"
                )
        agent_player_names = [agent.player_name for agent in agents_config]

        if not player_roles is None:
            logger.info("Validating player roles")
            self._validate_player_roles(player_roles, agent_player_names)
        logger.info("Validation completed successfully")

    def _validate_player_roles(self, player_roles, agent_player_names):
        if not isinstance(player_roles, dict):
            raise ValueError("player_roles should be a dictionary")
        role_player_names = list(player_roles.keys())
        if len(agent_player_names) > len(set(agent_player_names)):
            raise ValueError(
                f"player names should be unique, given player names {agent_player_names}"
            )

        if len(role_player_names) > len(set(role_player_names)):
            raise ValueError(
                f"player names should be unique, given player names {role_player_names}"
            )

        if len(agent_player_names) != len(role_player_names):
            raise ValueError(
                f"player names should be same in agents_config and player_roles, given player names {agent_player_names} and {role_player_names}"
            )
        assert sorted(agent_player_names) == sorted(role_player_names), (
            f"player names should be the same in agents_config and player_roles, "
            f"given player names {agent_player_names} and {role_player_names}"
        )

    def _monitor_game_and_save_result(
        self,
        all_players_agent_infra,
        path_to_final_transcript_and_log_dump,
        copy_transcripts=True,
        ignore_agent_failure=False,
    ):

        final_game_stat = self._monitor_game(
            all_players_agent_infra,
            path_to_final_transcript_and_log_dump,
            ignore_agent_failure=ignore_agent_failure,
        )
        self.log_game_result(final_game_stat)

        final_game_stat["logs"] = []
        final_game_stat["transcripts"] = []
        if not path_to_final_transcript_and_log_dump is None:
            logger.info(
                f"Copying game transcripts to {
                    path_to_final_transcript_and_log_dump}"
            )
            transcrip_path, log_paths, game_controller_log_path = (
                self._copy_game_transcripts_and_logs(
                    all_players_agent_infra,
                    path_to_final_transcript_and_log_dump,
                    copy_transcripts=copy_transcripts,
                )
            )
            final_game_stat["controller_log"] = game_controller_log_path
            if transcrip_path and len(transcrip_path.items()) > 0:
                final_game_stat["transcripts"] = transcrip_path
            if log_paths and len(log_paths.items()) > 0:
                final_game_stat["logs"] = log_paths

        return final_game_stat

    def log_game_result(self, final_game_stat):
        if final_game_stat["game_status"] == "ended":
            logger.debug(
                f"the game has ended gracefully , here is games stats {
                json.dumps(final_game_stat)}"
            )
        elif (
            final_game_stat["game_status"] == "terminated"
            or final_game_stat["game_status"] == "aborted"
        ):
            logger.error(
                f"Game did not end as expected, there is some error while running the game, {
                    final_game_stat["failure_game_stats"]}"
            )
        else:
            logger.error(f"Game did not end as expected, unexpected state")


if __name__ == "__main__":
    pass
